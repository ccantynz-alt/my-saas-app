export const runtime = "nodejs";

import { NextResponse } from "next/server";
import {
  defaultPublishedContent,
  setPublishedContent,
  type PublishedSiteContent,
} from "@/app/lib/publishedContentStore";

type Params = { projectId: string };

export async function GET(_req: Request, ctx: { params: Params }) {
  return NextResponse.json({
    ok: true,
    route: "finish-for-me",
    projectId: ctx.params.projectId,
  });
}

function safeString(v: unknown) {
  return typeof v === "string" ? v : "";
}

export async function POST(req: Request, ctx: { params: Params }): Promise<Response> {
  try {
    const { projectId } = ctx.params;

    let body: any = {};
    try {
      body = await req.json();
    } catch {
      body = {};
    }

    const businessName = safeString(body?.businessName).trim();
    const tone = safeString(body?.tone).trim();

    const content: PublishedSiteContent = defaultPublishedContent(projectId);

    if (businessName) {
      content.pages[""].sections[0].heading = `Welcome to ${businessName}`;
      content.pages[""].sections[0].body =
        `This website for ${businessName} was generated by the Agent and stored in KV â€” content updates can happen instantly without redeploying.`;

      content.pages["about"].sections[0].heading = `About ${businessName}`;
      content.pages["about"].sections[0].body =
        `${businessName} is focused on delivering clear value with automation-first workflows and a premium online presence.`;

      content.pages["contact"].sections[0].body =
        `Contact ${businessName} using your preferred method (email, form, helpdesk). This text is KV-backed and can be regenerated anytime.`;
    }

    if (tone) {
      content.pages[""].sections.push({
        id: "tone",
        heading: "Tone",
        body: `Requested tone: ${tone}. (We can later wire real AI generation here.)`,
      });
    }

    content.updatedAt = new Date().toISOString();

    await setPublishedContent(content);

    return NextResponse.json({
      ok: true,
      projectId,
      updatedAt: content.updatedAt,
      pages: Object.keys(content.pages),
    });
  } catch (err: any) {
    return NextResponse.json(
      { ok: false, error: err?.message || "Unknown error" },
      { status: 500 }
    );
  }
}
